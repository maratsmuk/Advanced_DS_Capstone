# -*- coding: utf-8 -*-
"""[Zero-crossings_in_time_series].feature_eng.python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wRnQycHN52WER5IOBU-FGaixXFWaevyQ
"""

def prepare_features(t,x,N_samples_per_unit,prediction_steps,degrees,current_time,poly):
    #Read the data for the window:
    t_data = t[current_time:current_time+N_samples_per_unit+prediction_steps]
    y_data = x[current_time:current_time+N_samples_per_unit+prediction_steps]
    #Transform the window's 1-D array of time steps into a polynomial features:
    t_poly = poly.fit_transform(t_data[:,np.newaxis])
    #Then scale the obtained polynomial features into the range (0,1):
    t_scaled = MinMaxScaler().fit_transform(t_poly)
    #Finally, divide the obtained array into the training and test sets:
    #The first "N_samples_per_unit" values are used for the training set, 
    # while the last "prediction_steps" values are used for prediction
    train_t = t_scaled[0:N_samples_per_unit]
    train_y = y_data[0:N_samples_per_unit]   
    predict_t = t_scaled[N_samples_per_unit:N_samples_per_unit+prediction_steps]
    predict_y = y_data[N_samples_per_unit:N_samples_per_unit+prediction_steps]
    #Obviously, in the real-life applications, there is no data in predict_y, 
    # so the last "prediction_steps" values in y_data can be zeros or something non-significant.
    return train_t,train_y,predict_t,predict_y

