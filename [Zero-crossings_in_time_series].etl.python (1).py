# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QNSngPF-SxDSMb_1MbhOjtW6cUzO1XEx
"""

import math
from math import exp, sin, cos, log, pi
import numpy as np
import matplotlib.pyplot as plt

a=[3.040,1.098,0.674,3.537,6.173,8.679,4.503,3.328,6.937,0.700]
k=[2.983,2.378,2.439,1.168,2.406,1.236,2.868,1.378,2.348,2.268]
c=[0.192,0.140,0.127,0.132,0.125,0.189,0.187,0.171,0.188,0.176]

functions_dict = {
      1: lambda x: -exp(sin(3.*x))+2.,
      2: lambda x: log(3.*x)*log(2.*x)-0.1,
      3: lambda x: cos(5*x) if x<=3.*pi/2. else cos(x),
      4: lambda x: 3.0-sin(2.*x+1.)-2.*sin(3.*x+2.)-3.*sin(4.*x+3.)-4.*sin(5.*x+4.)-5.*sin(6.*x+5.),
      5: lambda x: exp(-x)*sin(2.0*pi*x),
      6: lambda x: 10.0 - (1.0/(np.abs(k*(x-a))+c)).sum(),
      7: lambda x: x + sin(5.0*x),
      8: lambda x: -x + sin(3.0*x) + 1.,
      9: lambda x: sin(3.0*x) if x<=5 else 7.0*x*x-14.0*x-100.0,
      10: lambda x: cos(x)+2.0*cos(2.0*x)*exp(-x)
  }

minimal_roots_dict = {
      1: 0.2553,
      2: 0.2804,
      3: 0.3142,
      4: 0.4893,
      5: 0.5000,
      6: 0.6426,
      7: 0.8209,
      8: 1.0354,
      9: 1.0472,
      10: 1.1407
  }

class minimal_root_function():
    def __init__(self, func_number = 1):
        self.f = functions_dict[func_number]
        self.MR = minimal_roots_dict[func_number]
        self.a = 0.1
        self.b = 7.0

class ball_sim():
    def __init__(self,x0 = [0.0,0.0], t0 = 0.0, c = 0.75, T = 10., h = 0.5,g_lev = lambda t,x: 0.0):
        self.x = np.array([np.array(x0)])
        self.t = np.array([t0])
        self.c = c
        self.T = T
        self.h = h
        self.ground = np.array([g_lev(self.t[0],self.x[0])])
    def func(self,x,t=0):
        y = np.array(x,float)
        y[0] = x[1]
        y[1] = -9.81
        return y
    def solve(self,x0,t0):
        k1 = self.func(x0,t0)
        k2 = self.func(x0+self.h*k1/2,t0+self.h/2)
        k3 = self.func(x0+self.h*k2/2,t0+self.h/2)
        k4 = self.func(x0+self.h*k3,t0+self.h)
        y = x0+(self.h/6.)*(k1+2*k2+2*k3+k4)
        return y
    def step(self,g_lev):
        x_new = self.solve(self.x[-1],self.t[-1])
        t_new = self.t[-1]+self.h
        r = g_lev(t_new,x_new)
        if x_new[0] <= r:
            x_new[0] = r
            x_new[1] = -self.c*self.x[-1][1]
        self.x = np.append(self.x,np.array([x_new]),axis=0)
        self.t = np.append(self.t,t_new)
        self.ground = np.append(self.ground,r)
        return 0
    def simulate(self,g_lev):
        while self.t[-1]<self.T-self.h/10000:
            self.step(g_lev)
        fig = plt.figure(figsize=(10,8))
        ax1 = fig.add_subplot(311)
        ax2 = fig.add_subplot(312)
        ax3 = fig.add_subplot(313)
        ax1.plot(self.t,self.x[:,0],'blue')
        ax1.plot(self.t,self.ground,'red')
        fig.suptitle('Simulation of the bouncing ball')
        ax1.set_xlabel('time')
        ax1.set_ylabel('altitude')
        ax1.legend(['altitude','ground'])
        ax1.grid(True)
        ax2.plot(self.t,self.x[:,1],'black')
        ax2.set_xlabel('time')
        ax2.set_ylabel('velocity')
        ax2.legend(['velocity'])
        ax2.grid(True)
        ax3.plot(self.t,self.x[:,0]-self.ground,'blue')
        zero_crossing_pos = abs(self.x[:,0]-self.ground)==0
        ax3.plot(self.t[zero_crossing_pos],(self.x[:,0]-self.ground)[zero_crossing_pos],'ro')
        ax3.set_xlabel('time')
        ax3.set_ylabel('altitude')
        ax3.legend(['relative altitude w.r.t. ground level','zero-crossings'])
        ax3.grid(True)
        fig.savefig('Bouncing_ball'+str(self.ground[0])+'.png')

def generate_problem(fnum):
    if fnum>0:
      f = minimal_root_function(fnum)
      t0 = f.a
      T = f.b
      N = int((T-t0)*15000)
      h = (T-t0)/N
      t = np.arange(t0,T,h)
      x = []
      curr_sign = 1
      zero_points = []
      for i in range(t.shape[0]):
          x.append(f.f(t[i]))
          if np.sign(x[-1])*curr_sign <=0:
              if curr_sign ==1:
                  curr_sign = -1
              else:
                  curr_sign = 1
              if abs(x[-1])<=abs(x[-2]):
                  zero_points.append(t[i])
              else:
                  zero_points.append(t[i-1])
      first_zero = f.MR
    else:
      t0 = 0.
      T = 10.
      c = 0.75
      N = T*10000
      h = (T-t0)/N
      x0 = [10.,15.]
      def g_level(t,x):
        if fnum==-1:
          return 1.0
        else:
          return 5*math.sin(t)*math.sqrt(math.sin(x[0])**2 + math.sin(x[1])**2)
      ball_sim_process = ball_sim(x0,t0,c,T,h,g_level)
      ball_sim_process.simulate(g_level)
      t = ball_sim_process.t
      x = ball_sim_process.x[:,0]-ball_sim_process.ground
      zero_points = t[(abs(x)==0)]
      first_zero = zero_points[0]
    x = np.array(x)
    zero_points = np.array(zero_points)
    N_samples_per_unit = 1000
    prediction_steps = 100
    sigma = 0.01
    
    return t,x,t0,T,h,N_samples_per_unit,prediction_steps,first_zero,zero_points,sigma